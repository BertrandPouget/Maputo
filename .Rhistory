# dat1 = dat[1:len,]
# dat2 = dat[-c(1:len),]
# detach(dat)
#
# #Definiamo distanza e clusters e plottiamo
#
# dat.e <- dist(dat1[,1:3], method = "euclidean")
# dat.ec <- hclust(dat.e, method = "complete")
# cluster.ec1 <- cutree(dat.ec, k=3)
# cluster.ec1[which(cluster.ec1==argmax(t(table(cluster.ec1))))]=4
#
# dat.e <- dist(dat2[,1:3], method = "euclidean")
# dat.ec <- hclust(dat.e, method = "complete")
# cluster.ec2 <- cutree(dat.ec, k=3)
# cluster.ec2[which(cluster.ec2==argmax(t(table(cluster.ec2))))]=4
#
# cluster.ec <- c(cluster.ec1,cluster.ec2)
plot3d(dat_col[,1:3], col=cluster.ec+1, pch=19)
k=dat_col[which(dat_col[,1]==min(dat_col[,1])),5]
checki=intersect(unique(which(dat$clus==k)), which(values(img)[,4]==255))
for(i in checki) #se è del cluster 1, va eliminato
{
values(img)[i,1]=0
values(img)[i,2]=0
values(img)[i,3]=0
values(img)[i,4]=0
}
plotRGB(img)
img = brick("img__16.tif")
plotRGB(img)
names(img) = c("redBand","greenBand", "blueBand", "null")
dat = data.frame(values(img))
dat_col=dat[which(values(img)[,4]!=0),]
dat.e <- dist(dat_col[,1:3], method = "euclidean")
dat.ec <- hclust(dat.e, method = "complete")
cluster.ec <- cutree(dat.ec, k=4)
dat_col=cbind.data.frame(dat_col,cluster.ec)
clus=rep(0,dim(dat)[1])
j=0
for(i in row.names(dat_col))
{
j=j+1
clus[as.numeric(i)]=dat_col$cluster.ec[j]
}
dat=cbind.data.frame(dat,clus)
#Dividiamo il dataset in due parti per motivi computazionali
# attach(dat)
# len=dim(dat)[1]/2
# dat1 = dat[1:len,]
# dat2 = dat[-c(1:len),]
# detach(dat)
#
# #Definiamo distanza e clusters e plottiamo
#
# dat.e <- dist(dat1[,1:3], method = "euclidean")
# dat.ec <- hclust(dat.e, method = "complete")
# cluster.ec1 <- cutree(dat.ec, k=3)
# cluster.ec1[which(cluster.ec1==argmax(t(table(cluster.ec1))))]=4
#
# dat.e <- dist(dat2[,1:3], method = "euclidean")
# dat.ec <- hclust(dat.e, method = "complete")
# cluster.ec2 <- cutree(dat.ec, k=3)
# cluster.ec2[which(cluster.ec2==argmax(t(table(cluster.ec2))))]=4
#
# cluster.ec <- c(cluster.ec1,cluster.ec2)
plot3d(dat_col[,1:3], col=cluster.ec+1, pch=19)
k=dat_col[which(dat_col[,1]==min(dat_col[,1])),5]
checki=intersect(unique(which(dat$clus==k)), which(values(img)[,4]==255))
for(i in checki) #se è del cluster 1, va eliminato
{
values(img)[i,1]=0
values(img)[i,2]=0
values(img)[i,3]=0
values(img)[i,4]=0
}
plotRGB(img)
img = brick("img__100.tif")
plotRGB(img)
names(img) = c("redBand","greenBand", "blueBand", "null")
dat = data.frame(values(img))
dat_col=dat[which(values(img)[,4]!=0),]
dat.e <- dist(dat_col[,1:3], method = "euclidean")
dat.ec <- hclust(dat.e, method = "complete")
cluster.ec <- cutree(dat.ec, k=4)
dat_col=cbind.data.frame(dat_col,cluster.ec)
clus=rep(0,dim(dat)[1])
j=0
for(i in row.names(dat_col))
{
j=j+1
clus[as.numeric(i)]=dat_col$cluster.ec[j]
}
dat=cbind.data.frame(dat,clus)
#Dividiamo il dataset in due parti per motivi computazionali
# attach(dat)
# len=dim(dat)[1]/2
# dat1 = dat[1:len,]
# dat2 = dat[-c(1:len),]
# detach(dat)
#
# #Definiamo distanza e clusters e plottiamo
#
# dat.e <- dist(dat1[,1:3], method = "euclidean")
# dat.ec <- hclust(dat.e, method = "complete")
# cluster.ec1 <- cutree(dat.ec, k=3)
# cluster.ec1[which(cluster.ec1==argmax(t(table(cluster.ec1))))]=4
#
# dat.e <- dist(dat2[,1:3], method = "euclidean")
# dat.ec <- hclust(dat.e, method = "complete")
# cluster.ec2 <- cutree(dat.ec, k=3)
# cluster.ec2[which(cluster.ec2==argmax(t(table(cluster.ec2))))]=4
#
# cluster.ec <- c(cluster.ec1,cluster.ec2)
plot3d(dat_col[,1:3], col=cluster.ec+1, pch=19)
k=dat_col[which(dat_col[,1]==min(dat_col[,1])),5]
checki=intersect(unique(which(dat$clus==k)), which(values(img)[,4]==255))
for(i in checki) #se è del cluster 1, va eliminato
{
values(img)[i,1]=0
values(img)[i,2]=0
values(img)[i,3]=0
values(img)[i,4]=0
}
plotRGB(img)
img = brick("img__64.tif")
plotRGB(img)
names(img) = c("redBand","greenBand", "blueBand", "null")
dat = data.frame(values(img))
dat_col=dat[which(values(img)[,4]!=0),]
dat.e <- dist(dat_col[,1:3], method = "euclidean")
dat.ec <- hclust(dat.e, method = "complete")
cluster.ec <- cutree(dat.ec, k=4)
dat_col=cbind.data.frame(dat_col,cluster.ec)
clus=rep(0,dim(dat)[1])
j=0
for(i in row.names(dat_col))
{
j=j+1
clus[as.numeric(i)]=dat_col$cluster.ec[j]
}
dat=cbind.data.frame(dat,clus)
#Dividiamo il dataset in due parti per motivi computazionali
# attach(dat)
# len=dim(dat)[1]/2
# dat1 = dat[1:len,]
# dat2 = dat[-c(1:len),]
# detach(dat)
#
# #Definiamo distanza e clusters e plottiamo
#
# dat.e <- dist(dat1[,1:3], method = "euclidean")
# dat.ec <- hclust(dat.e, method = "complete")
# cluster.ec1 <- cutree(dat.ec, k=3)
# cluster.ec1[which(cluster.ec1==argmax(t(table(cluster.ec1))))]=4
#
# dat.e <- dist(dat2[,1:3], method = "euclidean")
# dat.ec <- hclust(dat.e, method = "complete")
# cluster.ec2 <- cutree(dat.ec, k=3)
# cluster.ec2[which(cluster.ec2==argmax(t(table(cluster.ec2))))]=4
#
# cluster.ec <- c(cluster.ec1,cluster.ec2)
plot3d(dat_col[,1:3], col=cluster.ec+1, pch=19)
k=dat_col[which(dat_col[,1]==min(dat_col[,1])),5]
checki=intersect(unique(which(dat$clus==k)), which(values(img)[,4]==255))
for(i in checki) #se è del cluster 1, va eliminato
{
values(img)[i,1]=0
values(img)[i,2]=0
values(img)[i,3]=0
values(img)[i,4]=0
}
plotRGB(img)
img = brick("img__185.tif")
plotRGB(img)
img = brick("img__186.tif")
img = brick("img__187.tif")
img = brick("img__188.tif")
plotRGB(img)
names(img) = c("redBand","greenBand", "blueBand", "null")
dat = data.frame(values(img))
dat_col=dat[which(values(img)[,4]!=0),]
dat.e <- dist(dat_col[,1:3], method = "euclidean")
dat.ec <- hclust(dat.e, method = "complete")
cluster.ec <- cutree(dat.ec, k=4)
dat_col=cbind.data.frame(dat_col,cluster.ec)
clus=rep(0,dim(dat)[1])
j=0
for(i in row.names(dat_col))
{
j=j+1
clus[as.numeric(i)]=dat_col$cluster.ec[j]
}
dat=cbind.data.frame(dat,clus)
#Dividiamo il dataset in due parti per motivi computazionali
# attach(dat)
# len=dim(dat)[1]/2
# dat1 = dat[1:len,]
# dat2 = dat[-c(1:len),]
# detach(dat)
#
# #Definiamo distanza e clusters e plottiamo
#
# dat.e <- dist(dat1[,1:3], method = "euclidean")
# dat.ec <- hclust(dat.e, method = "complete")
# cluster.ec1 <- cutree(dat.ec, k=3)
# cluster.ec1[which(cluster.ec1==argmax(t(table(cluster.ec1))))]=4
#
# dat.e <- dist(dat2[,1:3], method = "euclidean")
# dat.ec <- hclust(dat.e, method = "complete")
# cluster.ec2 <- cutree(dat.ec, k=3)
# cluster.ec2[which(cluster.ec2==argmax(t(table(cluster.ec2))))]=4
#
# cluster.ec <- c(cluster.ec1,cluster.ec2)
plot3d(dat_col[,1:3], col=cluster.ec+1, pch=19)
k=dat_col[which(dat_col[,1]==min(dat_col[,1])),5]
checki=intersect(unique(which(dat$clus==k)), which(values(img)[,4]==255))
for(i in checki) #se è del cluster 1, va eliminato
{
values(img)[i,1]=0
values(img)[i,2]=0
values(img)[i,3]=0
values(img)[i,4]=0
}
plotRGB(img)
img = brick("img__1188.tif")
img = brick("img__1683.tif")
plotRGB(img)
names(img) = c("redBand","greenBand", "blueBand", "null")
dat = data.frame(values(img))
dat_col=dat[which(values(img)[,4]!=0),]
dat.e <- dist(dat_col[,1:3], method = "euclidean")
dat.ec <- hclust(dat.e, method = "complete")
cluster.ec <- cutree(dat.ec, k=4)
dat_col=cbind.data.frame(dat_col,cluster.ec)
clus=rep(0,dim(dat)[1])
j=0
for(i in row.names(dat_col))
{
j=j+1
clus[as.numeric(i)]=dat_col$cluster.ec[j]
}
dat=cbind.data.frame(dat,clus)
#Dividiamo il dataset in due parti per motivi computazionali
# attach(dat)
# len=dim(dat)[1]/2
# dat1 = dat[1:len,]
# dat2 = dat[-c(1:len),]
# detach(dat)
#
# #Definiamo distanza e clusters e plottiamo
#
# dat.e <- dist(dat1[,1:3], method = "euclidean")
# dat.ec <- hclust(dat.e, method = "complete")
# cluster.ec1 <- cutree(dat.ec, k=3)
# cluster.ec1[which(cluster.ec1==argmax(t(table(cluster.ec1))))]=4
#
# dat.e <- dist(dat2[,1:3], method = "euclidean")
# dat.ec <- hclust(dat.e, method = "complete")
# cluster.ec2 <- cutree(dat.ec, k=3)
# cluster.ec2[which(cluster.ec2==argmax(t(table(cluster.ec2))))]=4
#
# cluster.ec <- c(cluster.ec1,cluster.ec2)
plot3d(dat_col[,1:3], col=cluster.ec+1, pch=19)
k=dat_col[which(dat_col[,1]==min(dat_col[,1])),5]
checki=intersect(unique(which(dat$clus==k)), which(values(img)[,4]==255))
for(i in checki) #se è del cluster 1, va eliminato
{
values(img)[i,1]=0
values(img)[i,2]=0
values(img)[i,3]=0
values(img)[i,4]=0
}
plotRGB(img)
img = brick("img__1573.tif")
plotRGB(img)
names(img) = c("redBand","greenBand", "blueBand", "null")
dat = data.frame(values(img))
dat_col=dat[which(values(img)[,4]!=0),]
dat.e <- dist(dat_col[,1:3], method = "euclidean")
dat.ec <- hclust(dat.e, method = "complete")
cluster.ec <- cutree(dat.ec, k=4)
dat_col=cbind.data.frame(dat_col,cluster.ec)
clus=rep(0,dim(dat)[1])
j=0
for(i in row.names(dat_col))
{
j=j+1
clus[as.numeric(i)]=dat_col$cluster.ec[j]
}
dat=cbind.data.frame(dat,clus)
plot3d(dat_col[,1:3], col=cluster.ec+1, pch=19)
k=dat_col[which(dat_col[,1]==min(dat_col[,1])),5]
checki=intersect(unique(which(dat$clus==k)), which(values(img)[,4]==255))
for(i in checki) #se è del cluster 1, va eliminato
{
values(img)[i,1]=0
values(img)[i,2]=0
values(img)[i,3]=0
values(img)[i,4]=0
}
plotRGB(img)
rm(list=ls())
graphics.off()
library(sf)
library(raster)
library(sp)
library(ggplot2)
library(rgdal)
library(rgl)
setwd("C:/Users/giuli/OneDrive/Desktop/Maputo")
datini=st_read("datini.shp")
rmean=rvar=rmed=rmin=rmax=gmean=gvar=gmed=gmin=gmax=bmean=bvar=bmed=bmin=bmax=rep(0,dim(datini)[1])
lance=cbind(datini,rmean,rvar,rmed,rmin,rmax,gmean,gvar,gmed,gmin,gmax,bmean,bvar,bmed,bmin,bmax)
setwd("C:/Users/giuli/OneDrive/Desktop/Maputo/rater_mask_datonite")
# Abitiamo le colonne e creiamo il nuvo dataset
for(i in 1:20)
{
img = brick(lance$image[i])
dat = data.frame(values(img))
dat_col=dat[which(values(img)[,4]!=0),]
dat.e <- dist(dat_col[,1:3], method = "euclidean")
dat.ec <- hclust(dat.e, method = "complete")
cluster.ec <- cutree(dat.ec, k=4)
dat_col=cbind.data.frame(dat_col,cluster.ec)
clus=rep(0,dim(dat)[1])
j=0
for(i in row.names(dat_col))
{
j=j+1
clus[as.numeric(i)]=dat_col$cluster.ec[j]
}
dat=cbind.data.frame(dat,clus)
k=dat_col[which(dat_col[,1]==min(dat_col[,1])),5]
checki=intersect(unique(which(dat$clus==k)), which(values(img)[,4]==255))
for(i in checki) #se è del cluster 1, va eliminato
{
values(img)[i,1]=0
values(img)[i,2]=0
values(img)[i,3]=0
values(img)[i,4]=0
}
# CALCOLO VARIABILI
names(img) = c("r","g", "b", "null")
colori = data.frame(values(img)[which(apply(values(img),1,sum)!=0),])
lance$rmean[i]=mean(colori$r)
lance$rvar[i]=var(colori$r)
lance$rmed[i]=median(colori$r)
lance$rmin[i]=min(colori$r)
lance$rmax[i]=max(colori$r)
lance$gmean[i]=mean(colori$g)
lance$gvar[i]=var(colori$g)
lance$gmed[i]=median(colori$g)
lance$gmin[i]=min(colori$g)
lance$gmax[i]=max(colori$g)
lance$bmean[i]=mean(colori$b)
lance$bvar[i]=var(colori$b)
lance$bmed[i]=median(colori$b)
lance$bmin[i]=min(colori$b)
lance$bmax[i]=max(colori$b)
}
View(colori)
for(i in 1:20)
{
img = brick(lance$image[i])
dat = data.frame(values(img))
dat_col=dat[which(values(img)[,4]!=0),]
dat.e <- dist(dat_col[,1:3], method = "euclidean")
dat.ec <- hclust(dat.e, method = "complete")
cluster.ec <- cutree(dat.ec, k=4)
dat_col=cbind.data.frame(dat_col,cluster.ec)
clus=rep(0,dim(dat)[1])
j=0
for(ii in row.names(dat_col))
{
j=j+1
clus[as.numeric(ii)]=dat_col$cluster.ec[j]
}
dat=cbind.data.frame(dat,clus)
k=dat_col[which(dat_col[,1]==min(dat_col[,1])),5]
checki=intersect(unique(which(dat$clus==k)), which(values(img)[,4]==255))
for(iii in checki) #se è del cluster 1, va eliminato
{
values(img)[iii,1]=0
values(img)[iii,2]=0
values(img)[iii,3]=0
values(img)[iii,4]=0
}
# CALCOLO VARIABILI
names(img) = c("r","g", "b", "null")
colori = data.frame(values(img)[which(apply(values(img),1,sum)!=0),])
lance$rmean[i]=mean(colori$r)
lance$rvar[i]=var(colori$r)
lance$rmed[i]=median(colori$r)
lance$rmin[i]=min(colori$r)
lance$rmax[i]=max(colori$r)
lance$gmean[i]=mean(colori$g)
lance$gvar[i]=var(colori$g)
lance$gmed[i]=median(colori$g)
lance$gmin[i]=min(colori$g)
lance$gmax[i]=max(colori$g)
lance$bmean[i]=mean(colori$b)
lance$bvar[i]=var(colori$b)
lance$bmed[i]=median(colori$b)
lance$bmin[i]=min(colori$b)
lance$bmax[i]=max(colori$b)
}
View(lance)
rmean=rvar=rmed=rmin=rmax=gmean=gvar=gmed=gmin=gmax=bmean=bvar=bmed=bmin=bmax=rep(0,dim(datini)[1])
lance=cbind(datini,rmean,rvar,rmed,rmin,rmax,gmean,gvar,gmed,gmin,gmax,bmean,bvar,bmed,bmin,bmax)
# DIRECTORY RATER_MASK_DATONITE
# setwd("C:/Users/markh/Desktop/UniversitÃ /Maputo/rater_mask_datonite")
# Abitiamo le colonne e creiamo il nuvo dataset
for(i in 1:20)
{
img = brick(lance$image[i])
dat = data.frame(values(img))
dat_col=dat[which(values(img)[,4]!=0),]
dat.e <- dist(dat_col[,1:3], method = "euclidean")
dat.ec <- hclust(dat.e, method = "complete")
cluster.ec <- cutree(dat.ec, k=4)
dat_col=cbind.data.frame(dat_col,cluster.ec)
clus=rep(0,dim(dat)[1])
j=0
for(ii in row.names(dat_col))
{
j=j+1
clus[as.numeric(ii)]=dat_col$cluster.ec[j]
}
dat=cbind.data.frame(dat,clus)
k=dat_col[which(dat_col[,1]==min(dat_col[,1])),5]
checki=intersect(unique(which(dat$clus==k)), which(values(img)[,4]==255))
for(iii in checki) #se è del cluster 1, va eliminato
{
values(img)[iii,]=c(0,0,0,0)
}
# CALCOLO VARIABILI
names(img) = c("r","g", "b", "null")
colori = data.frame(values(img)[which(apply(values(img),1,sum)!=0),])
lance$rmean[i]=mean(colori$r)
lance$rvar[i]=var(colori$r)
lance$rmed[i]=median(colori$r)
lance$rmin[i]=min(colori$r)
lance$rmax[i]=max(colori$r)
lance$gmean[i]=mean(colori$g)
lance$gvar[i]=var(colori$g)
lance$gmed[i]=median(colori$g)
lance$gmin[i]=min(colori$g)
lance$gmax[i]=max(colori$g)
lance$bmean[i]=mean(colori$b)
lance$bvar[i]=var(colori$b)
lance$bmed[i]=median(colori$b)
lance$bmin[i]=min(colori$b)
lance$bmax[i]=max(colori$b)
}
View(lance)
dim(datini)[1]
rmean=rvar=rmed=rmin=rmax=gmean=gvar=gmed=gmin=gmax=bmean=bvar=bmed=bmin=bmax=rep(0,dim(datini)[1])
lance=cbind(datini,rmean,rvar,rmed,rmin,rmax,gmean,gvar,gmed,gmin,gmax,bmean,bvar,bmed,bmin,bmax)
# DIRECTORY RATER_MASK_DATONITE
# setwd("C:/Users/markh/Desktop/UniversitÃ /Maputo/rater_mask_datonite")
# Abitiamo le colonne e creiamo il nuvo dataset
for(i in 1:dim(datini)[1])
{
img = brick(lance$image[i])
dat = data.frame(values(img))
dat_col=dat[which(values(img)[,4]!=0),]
dat.e <- dist(dat_col[,1:3], method = "euclidean")
dat.ec <- hclust(dat.e, method = "complete")
cluster.ec <- cutree(dat.ec, k=4)
dat_col=cbind.data.frame(dat_col,cluster.ec)
clus=rep(0,dim(dat)[1])
j=0
for(ii in row.names(dat_col))
{
j=j+1
clus[as.numeric(ii)]=dat_col$cluster.ec[j]
}
dat=cbind.data.frame(dat,clus)
k=dat_col[which(dat_col[,1]==min(dat_col[,1])),5]
checki=intersect(unique(which(dat$clus==k)), which(values(img)[,4]==255))
for(iii in checki) #se è del cluster 1, va eliminato
{
values(img)[iii,]=c(0,0,0,0)
}
# CALCOLO VARIABILI
names(img) = c("r","g", "b", "null")
colori = data.frame(values(img)[which(apply(values(img),1,sum)!=0),])
lance$rmean[i]=mean(colori$r)
lance$rvar[i]=var(colori$r)
lance$rmed[i]=median(colori$r)
lance$rmin[i]=min(colori$r)
lance$rmax[i]=max(colori$r)
lance$gmean[i]=mean(colori$g)
lance$gvar[i]=var(colori$g)
lance$gmed[i]=median(colori$g)
lance$gmin[i]=min(colori$g)
lance$gmax[i]=max(colori$g)
lance$bmean[i]=mean(colori$b)
lance$bvar[i]=var(colori$b)
lance$bmed[i]=median(colori$b)
lance$bmin[i]=min(colori$b)
lance$bmax[i]=max(colori$b)
}
# DIRECTORY MAPUTO
# setwd("C:/Users/markh/Desktop/UniversitÃ /Maputo")
st_write(lance,"lance.shp")
warnings()
View(datini)
setwd("C:/Users/giuli/OneDrive/Desktop/Maputo")
library(sf)
dat <- st_read("datonite.shp")
View(dat)
